import argparse
import datetime
import json
import os
import pickle
import socket
import threading
from base64 import b64decode, b64encode

from Crypto.Cipher import AES, PKCS1_OAEP
from Crypto.PublicKey import RSA
from ellipticcurve import Ecdsa, PrivateKey
from termcolor import colored


class Client:
    def __init__(self, server: str, port: int, username: str) -> None:
        self.server = server
        self.port = port
        self.username = username

    def create_connection(self) -> None:
        """
        Create the connection to the server. Setup username, keys.
        Calling exchange secret and public key methods
        """
        self._socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

        try:
            self._socket.connect((self.server, self.port))
        except Exception as e:
            print(colored(f"[!] {e}", "red"))

        self._socket.send(
            self.username.encode()
        )  # Inform the server about the username connected
        print(colored("[+] Connected successfully", "yellow"))
        print(colored("[+] Exchanging keys", "yellow"))

        self.create_key_pairs()  # Create key pairs
        self.exchange_public_keys()  # Initial public key exchange

        global server_signature
        server_signature = (
            self.get_server_signature()
        )  # Function to get signature from the server

        global secret_key  # Global variable to hold the secret key for AES encryption
        secret_key = (
            self.handle_secret()
        )  # Function to get the secret generated by the server

        print(colored("[+] Initial set up had been completed!", "yellow"))
        print(colored("[+] Now you can start to exchange messages", "yellow"))

        message_handler = threading.Thread(target=self.handle_messages, args=())
        message_handler.start()

        input_handler = threading.Thread(target=self.input_handler, args=())
        input_handler.start()

    def handle_messages(self) -> None:
        """
        Handle receiving messages.
        """
        while True:
            message = self._socket.recv(1024).decode()
            sign = pickle.loads(self._socket.recv(1024))
            if message and sign:
                if Ecdsa.verify(message, sign, server_signature):
                    print(
                        colored(
                            "Message confirmed, it really came from the server!",
                            "green",
                        )
                    )

                    key = secret_key  # The secret key to use for AES decryption
                    decrypt_message = json.loads(message)

                    iv = b64decode(
                        decrypt_message["iv"]
                    )  # Take out the initialization vector and b64 decode it
                    cipherText = b64decode(
                        decrypt_message["ciphertext"]
                    )  # Take out the ciphertext and b64 decode it
                    cipher = AES.new(key, AES.MODE_CFB, iv=iv)  # Create AES object

                    msg = cipher.decrypt(
                        cipherText
                    )  # Use the object to decrypt the ciphertext
                    current_time = datetime.datetime.now()
                    print(
                        colored(
                            f"{current_time.strftime('%Y-%m-%d %H:%M:%S ')} {msg.decode()}",
                            "green",
                        )
                    )
                else:
                    print(
                        colored(
                            "Verification failed. he message did not come from the server!",
                            "red",
                        )
                    )
            else:
                print(colored("[!] Lost the connection to the server", "red"))
                print(colored("[!] Closing down the connection", "red"))

                self._socket.shutdown(socket.SHUT_RDWR)
                os._exit(0)

    def input_handler(self) -> None:
        """
        Handle user input and send message.
        """
        while True:
            message = input()
            if message == "EXIT":
                break

            key = secret_key
            cipher = AES.new(key, AES.MODE_CFB)  # Initialize AES object for encryption

            message_to_encrypt = f"{self.username}: {message}"
            msgBytes = (
                message_to_encrypt.encode()
            )  # Byte encode it, because AES input must be byte encoded
            encrypted_message = cipher.encrypt(msgBytes)

            # Generate the initialization vector, b64encode it, than utf-8 representation to send
            iv = b64encode(cipher.iv).decode("utf-8")
            message = b64encode(encrypted_message).decode("utf-8")
            result = json.dumps({"iv": iv, "ciphertext": message})

            self._socket.send(result.encode())

        self._socket.shutdown(socket.SHUT_RDWR)
        os._exit(0)

    def handle_secret(self) -> bytes:
        """
        Receiving the secret key for symmetric encryption
        """
        secret_key = self._socket.recv(1024)  # The secret key coming from the server

        # Import the client private key and decrypt the secret by using client private key
        private_key = RSA.importKey(open("client_private_key.pem").read())
        cipher = PKCS1_OAEP.new(private_key)

        return cipher.decrypt(secret_key)

    def exchange_public_keys(self) -> None:
        """
        Send the public key to the server to encrypt the secret.
        The secret is generated by the server and used for symmetric encryption.
        """
        try:
            print(colored("[+] Getting public key from the server", "blue"))
            server_public_key = self._socket.recv(1024).decode()
            server_public_key = RSA.importKey(server_public_key)

            print(colored("[+] Sending public key to server", "blue"))
            public_pem_key = RSA.importKey(open("client_public_key.pem").read())
            self._socket.send(public_pem_key.exportKey())
            print(colored("[+] Exchange completed!", "yellow"))

        except Exception as e:
            print(colored(f"[!] ERROR, you messed up something.... {e}", "red"))

    def get_server_signature(self) -> str:
        """
        Get public key for signature from server.
        """
        try:
            print(colored("[+] Getting signature public key from the server", "blue"))
            server_sign_public_key = self._socket.recv(1024).decode()
            server_sign_public_key = (
                PrivateKey().publicKey().fromPem(server_sign_public_key)
            )
            print(colored("[+] Key retrieved successfully!", "yellow"))

            return server_sign_public_key

        except Exception as e:
            print(colored(f"[!] ERROR, you messed up something.... {e}", "red"))

    @staticmethod
    def create_key_pairs() -> None:
        """
        Generate public and private key pairs.
        """
        try:
            private_key = RSA.generate(2048)
            public_key = private_key.publickey()

            private_pem = private_key.exportKey().decode()
            public_pem = public_key.exportKey().decode()

            with open("client_private_key.pem", "w") as private:
                private.write(private_pem)

            with open("client_public_key.pem", "w") as public:
                public.write(public_pem)

        except Exception as e:
            print(colored(f"[!] ERROR, you messed up something.... {e}", "red"))


if __name__ == "__main__":
    arg_parse = argparse.ArgumentParser()
    arg_parse.add_argument("-s", "--server", required=True, help="Server IP to connect")
    arg_parse.add_argument(
        "-p", "--port", required=True, type=int, help="Port the server listening on"
    )
    arg_parse.add_argument(
        "-u", "--username", required=True, help="Username of the user"
    )
    args = arg_parse.parse_args()

    client = Client(args.server, args.port, args.username)
    client.create_connection()
